# =============================================================================
# CAPSTONE 2 – FULLY WORKING IN UHG DATABRICKS (UAIS Azure OpenAI)
# Manual ReAct Agent – Option 1 – Uses your exact course connection
# =============================================================================

import json
from datetime import datetime
from typing import List, Dict, Any
import pandas as pd
import httpx
from tenacity import retry, stop_after_attempt, wait_random_exponential

# ----------------------------------------------------------------------
# 1. AUTHENTICATION – EXACTLY AS IN YOUR COURSE
# ----------------------------------------------------------------------
def get_access_token():
    auth = "https://api.uhg.com/oauth2/token"
    scope = "https://api.uhg.com/.default"
    grant_type = "client_credentials"
    with httpx.Client() as client:
        body = {
            "grant_type": grant_type,
            "scope": scope,
            "client_id": dbutils.secrets.get(scope="AIML_Training", key="client_id"),
            "client_secret": dbutils.secrets.get(scope="AIML_Training", key="client_secret"),
        }
        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        resp = client.post(auth, headers=headers, data=body, timeout=60)
        return resp.json()["access_token"]

# Load environment variables from UAIS_vars.env (as in course)
from dotenv import load_dotenv
load_dotenv('./Data/UAIS_vars.env')

endpoint = os.environ.get("MODEL_ENDPOINT")
model_name = os.environ.get("MODEL_NAME")
project_id = os.environ.get("PROJECT_ID")
api_version = os.environ.get("API_VERSION")

# Official client from course
import openai
chat_client = openai.AzureOpenAI(
    azure_endpoint=endpoint,
    api_version=api_version,
    azure_deployment=model_name,
    azure_ad_token=get_access_token(),
    default_headers={"projectId": project_id}
)

# ----------------------------------------------------------------------
# 2. LLM CALL FUNCTION – EXACTLY AS IN COURSE
# ----------------------------------------------------------------------
@retry(wait=wait_random_exponential(min=45, max=120), stop=stop_after_attempt(6))
def query_llm(prompt_messages, max_tokens=4096, temperature=0.0, top_p=1.0):
    response = chat_client.chat.completions.create(
        messages=prompt_messages,
        max_tokens=max_tokens,
        temperature=temperature,
        top_p=top_p,
        model=model_name
    )
    return response.choices[0].message.content

# ----------------------------------------------------------------------
# 3. LOAD DATA
# ----------------------------------------------------------------------
import json
with open("./Data/reference_codes.json") as f:
    ref = json.load(f)
    icd10_map = ref.get("icd10", {})
    cpt_map = ref.get("cpt", {})

with open("./Data/insurance_policies.json") as f:
    policies = json.load(f)
    policy_dict = {p["policy_id"]: p for p in policies}

with open("./Data/validation_records.json") as f:
    validation_records = json.load(f)

with open("./Data/test_records.json") as f:
    test_records = json.load(f)

# ----------------------------------------------------------------------
# 4. AGE CALCULATION
# ----------------------------------------------------------------------
def compute_age(dob: str, dos: str) -> int:
    b = datetime.strptime(dob, "%Y-%m-%d")
    s = datetime.strptime(dos, "%Y-%m-%d")
    age = s.year - b.year
    if (s.month, s.day) < (b.month, b.day):
        age -= 1
    return age

for recs in [validation_records, test_records]:
    for r in recs:
        r["age"] = compute_age(r["date_of_birth"], r["date_of_service"])

# ----------------------------------------------------------------------
# 5. TOOLS (using raw query_llm)
# ----------------------------------------------------------------------
def summarize_patient_record(record_str: str) -> str:
    messages = [
        {"role": "developer", "content": """You are an expert medical claims processor. 
         Create a structured summary with exactly these 7 sections in order:
         • Patient Demographics (name, gender, age)
         • Insurance Policy ID
         • Diagnoses and Descriptions
         • Procedures and Descriptions
         • Preauthorization Status
         • Billed Amount (in USD)
         • Date of Service
         Use the ICD-10 and CPT descriptions provided."""},
        {"role": "user", "content": f"""Mappings:
ICD-10: {json.dumps(icd10_map)}
CPT: {json.dumps(cpt_map)}

Patient record:
{record_str}

Return only the summary."""}
    ]
    return query_llm(messages, temperature=0)

def summarize_policy_guideline(policy_id: str) -> str:
    policy = policy_dict.get(policy_id)
    if not policy:
        return "Policy not found."
    
    messages = [
        {"role": "developer", "content": """Summarize the insurance policy with:
         • Policy Details
         • Covered Procedures (each with: code, description, diagnoses, gender, age range, preauth, notes)
         Use human-readable CPT/ICD descriptions."""},
        {"role": "user", "content": f"""Mappings:
CPT: {json.dumps(cpt_map)}
ICD-10: {json.dumps(icd10_map)}

Policy:
{json.dumps(policy)}"""}
    ]
    return query_llm(messages, temperature=0)

def check_claim_coverage(record_summary: str, policy_summary: str) -> str:
    messages = [
        {"role": "developer", "content": """You are a senior claims adjudicator.
         Approve only if ALL criteria are met:
         - Diagnosis matches
         - Procedure listed
         - Age in range [lower, upper)
         - Gender matches
         - Preauth required → obtained
         Output exactly 3 sections:
         • Coverage Review (step-by-step)
         • Summary of Findings
         • Final Decision: APPROVE or ROUTE FOR REVIEW + short reason"""},
        {"role": "user", "content": f"""Patient:
{record_summary}

Policy:
{policy_summary}"""}
    ]
    return query_llm(messages, temperature=0)

# ----------------------------------------------------------------------
# 6. MANUAL REACT AGENT (simplified state machine)
# ----------------------------------------------------------------------
def run_agent_on_record(rec: Dict) -> str:
    record_str = json.dumps(rec, indent=2)
    
    # Step 1
    patient_summary = summarize_patient_record(record_str)
    
    # Extract policy_id
    import re
    policy_match = re.search(r"Insurance Policy ID[:\s]+([A-Z0-9]+)", patient_summary)
    policy_id = policy_match.group(1) if policy_match else rec["insurance_policy_id"]
    
    # Step 2
    policy_summary = summarize_policy_guideline(policy_id)
    
    # Step 3
    coverage_result = check_claim_coverage(patient_summary, policy_summary)
    
    # Final decision
    messages = [
        {"role": "developer", "content": """After coverage review, output ONLY these two lines:
Decision: APPROVE
Reason: <concise reason>

or

Decision: ROUTE FOR REVIEW
Reason: <concise reason>

No extra text."""},
        {"role": "user", "content": coverage_result}
    ]
    final = query_llm(messages, temperature=0)
    return final.strip()

# ----------------------------------------------------------------------
# 7. GENERATE SUBMISSION.CSV
# ----------------------------------------------------------------------
results = []
for rec in test_records:
    print(f"Processing {rec['patient_id']}...")
    resp = run_agent_on_record(rec)
    results.append({"patient_id": rec["patient_id"], "generated_response": resp})

submission_df = pd.DataFrame(results)[["patient_id", "generated_response"]]
submission_df.to_csv("submission.csv", index=False)

print("\nsubmission.csv created successfully!")
display(submission_df)
