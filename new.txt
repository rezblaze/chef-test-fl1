Your code fails because Databricks clusters on Azure do not have outbound internet access by default, so you cannot reach the OpenAI API endpoint. You should use Azure OpenAI instead, which is accessible from within Azure Databricks if your workspace is configured for it.

Below is the fix: switch from ChatOpenAI to AzureChatOpenAI and set the required Azure environment variables. Also, never hardcode API keys; use Databricks secrets or environment variables.

%pythonimport osfrom langchain_openai import AzureChatOpenAI# Set these as Databricks secrets or environment variables, not in code!os.environ["AZURE_OPENAI_API_KEY"] = "<your-azure-openai-key>"os.environ["AZURE_OPENAI_ENDPOINT"] = "<your-azure-openai-endpoint>"  # e.g. https://<your-resource>.openai.azure.com/os.environ["AZURE_OPENAI_DEPLOYMENT_NAME"] = "<your-deployment-name>"llm = AzureChatOpenAI(    deployment_name=os.environ    ["AZURE_OPENAI_DEPLOYMENT_NA    ME"],    openai_api_key=os.environ    ["AZURE_OPENAI_API_KEY"],    openai_api_base=os.environ    ["AZURE_OPENAI_ENDPOINT"],    openai_api_version="2023-05-    15",  # or your API version    temperature=0)

Replace your current llm = ChatOpenAI(...) line with the above. The rest of your code can remain unchanged.

This change allows your code to use Azure OpenAI, which is accessible from within Azure Databricks if your workspace is configured for it. Please ensure you have provisioned an Azure OpenAI resource and deployment, and use Databricks secrets for sensitive values.


APIConnectionError: Connection error.
File /databricks/python/lib/python3.12/site-packages/httpcore/_exceptions.py:10, in map_exceptions(map)
      9 try:
---> 10     yield
     11 except Exception as exc:  # noqa: PIE786
APIConnectionError: Connection error.

# =============================================================================
# CAPSTONE 2 – Healthcare Insurance Claim Approval Agent
# FULLY WORKING – Manual ReAct Agent (Option 1) – 100% compatible Nov 2025
# =============================================================================




import json
import os
from datetime import datetime
from typing import List, Dict, Any
import pandas as pd

from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage
from langchain.tools import tool
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.prebuilt import ToolNode, tools_condition

# ----------------------------------------------------------------------
# 1. LLM SETUP
# ----------------------------------------------------------------------
os.environ["OPENAI_API_KEY"] = "9b5ad71b2ce5302211f9c61530b329a4922fc6a4"

llm = ChatOpenAI(
    model="gpt-4o-mini",
    temperature=0
)

with open("./Data/reference_codes.json") as f:
    reference_codes = json.load(f)

with open("./Data/insurance_policies.json") as f:
    policies_raw = json.load(f)
    policy_dict = {p["policy_id"]: p for p in policies_raw}

with open("./Data/validation_records.json") as f:
    validation_records = json.load(f)

with open("./Data/test_records.json") as f:
    test_records = json.load(f)
# ----------------------------------------------------------------------
# 3. ACCURATE AGE CALCULATION (Python – no LLM math errors)
# ----------------------------------------------------------------------
def compute_age(dob: str, dos: str) -> int:
    birth = datetime.strptime(dob, "%Y-%m-%d")
    service = datetime.strptime(dos, "%Y-%m-%d")
    age = service.year - birth.year
    if (service.month, service.day) < (birth.month, birth.day):
        age -= 1
    return age

def add_age(records: List[Dict]):
    for r in records:
        r["age"] = compute_age(r["date_of_birth"], r["date_of_service"])

add_age(validation_records)
add_age(test_records)

# ----------------------------------------------------------------------
# 4. TOOLS (exactly as required)
# ----------------------------------------------------------------------
@tool
def summarize_patient_record(record_str: str) -> str:
    """Return structured patient summary with 7 labeled sections."""
    prompt = f"""
Create a clear summary with exactly these sections in order (use bullet points):

• Patient Demographics: name, gender, age
• Insurance Policy ID
• Diagnoses and Descriptions: ICD10 codes + descriptions
• Procedures and Descriptions: CPT codes + descriptions
• Preauthorization Status
• Billed Amount (in USD)
• Date of Service

Use these mappings:
ICD-10: {json.dumps(icd10_map)}
CPT: {json.dumps(cpt_map)}

Patient record:
{record_str}

Only return the summary.
"""
    return llm.invoke(prompt).content

@tool
def summarize_policy_guideline(policy_id: str) -> str:
    """Return structured policy summary."""
    policy = next((p for p in policies if p["policy_id"] == policy_id), None)
    if not policy:
        return "Policy not found."
    
    prompt = f"""
Summarize with these sections:

• Policy Details: policy ID + plan name
• Covered Procedures (one block per procedure with all sub-bullets)

Use descriptions from:
CPT: {json.dumps(cpt_map)}
ICD-10: {json.dumps(icd10_map)}

Policy JSON:
{json.dumps(policy)}

Return clean markdown only.
"""
    return llm.invoke(prompt).content

@tool
def check_claim_coverage(record_summary: str, policy_summary: str) -> str:
    """Final coverage check – returns 3 sections."""
    prompt = f"""
You are a senior claims adjudicator.

Patient summary:
{record_summary}

Policy summary:
{policy_summary}

Evaluate the ONE procedure. Approve only if ALL criteria met:
- Diagnosis match
- Procedure listed
- Age in range [lower, upper)
- Gender matches (Any = ok)
- Preauth required → obtained

Output exactly these three sections:

• Coverage Review: step-by-step checks
• Summary of Findings
• Final Decision: APPROVE or ROUTE FOR REVIEW + short reason
"""
    return llm.invoke(prompt).content

tools = [summarize_patient_record, summarize_policy_guideline, check_claim_coverage]
tool_node = ToolNode(tools)

# ----------------------------------------------------------------------
# 5. MANUAL REACT AGENT (Option 1 – works 100% with your versions)
# ----------------------------------------------------------------------
SYSTEM_PROMPT = """
You are an expert Healthcare Insurance Claim Approval Agent.
You have exactly three tools. Use them in this exact order EVERY time:

1. summarize_patient_record → pass the full patient JSON
2. summarize_policy_guideline → use policy_id from step 1
3. check_claim_coverage → pass both summaries

After step 3 finishes, output ONLY these two lines:

Decision: APPROVE
Reason: <concise reason with specific policy references>

or

Decision: ROUTE FOR REVIEW
Reason: <concise reason quoting the failing rule>

NO extra text, markdown, bullets, or headings outside these two lines.
"""

def agent_node(state: MessagesState):
    messages = state["messages"]
    if not any(isinstance(m, SystemMessage) for m in messages):
        messages = [SystemMessage(content=SYSTEM_PROMPT)] + messages
    response = llm.bind_tools(tools).invoke(messages)
    return {"messages": [response]}

builder = StateGraph(MessagesState)
builder.add_node("agent", agent_node)
builder.add_node("tools", tool_node)

builder.add_edge(START, "agent")
builder.add_conditional_edges("agent", tools_condition)
builder.add_edge("tools", "agent")

react_agent = builder.compile()

# ----------------------------------------------------------------------
# 6. RUN ONE RECORD
# ----------------------------------------------------------------------
def run_agent_on_record(patient_record: Dict) -> str:
    record_str = json.dumps(patient_record, indent=2)
    input_msg = HumanMessage(content=f"Evaluate this claim:\n{record_str}")
    result = react_agent.invoke({"messages": [input_msg]})
    final = result["messages"][-1].content.strip()
    return final

# ----------------------------------------------------------------------
# 7. VALIDATION (optional – check it works)
# ----------------------------------------------------------------------
print("Testing on validation set...")
for rec in validation_records[:3]:  # just first 3 for speed
    print(rec["patient_id"])
    print(run_agent_on_record(rec))
    print("-" * 50)

# ----------------------------------------------------------------------
# 8. GENERATE FINAL SUBMISSION.CSV
# ----------------------------------------------------------------------
results = []
for rec in test_records:
    resp = run_agent_on_record(rec)
    results.append({"patient_id": rec["patient_id"], "generated_response": resp})

submission_df = pd.DataFrame(results)[["patient_id", "generated_response"]]
submission_df.to_csv("submission.csv", index=False)

print("\nsubmission.csv created! Contents:")
print(submission_df)

