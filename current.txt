import json
import pandas as pd
from datetime import datetime
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage
from langchain_core.tools import tool
from langgraph.graph import StateGraph, MessagesState
from langgraph.prebuilt import ToolNode, tools_condition

# --- Setup ---
llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

with open("./Data/reference_codes.json") as f:
    reference_codes = json.load(f)

with open("./Data/insurance_policies.json") as f:
    policies_raw = json.load(f)
    policy_dict = {p["policy_id"]: p for p in policies_raw}

with open("./Data/validation_records.json") as f:
    validation_records = json.load(f)

with open("./Data/test_records.json") as f:
    test_records = json.load(f)

# --- Helper: calculate age ---
def calc_age(dob, dos):
    b = datetime.strptime(dob, "%Y-%m-%d")
    s = datetime.strptime(dos, "%Y-%m-%d")
    age = s.year - b.year
    if (s.month, s.day) < (b.month, b.day):
        age -= 1
    return age

for recs in [validation_records, test_records]:
    for r in recs:
        r['age'] = calc_age(r['date_of_birth'], r['date_of_service'])

# --- Tools ---
@tool
def summarize_patient_record(record_str: str) -> str:
    return llm.invoke(f"Summarize patient record:\n{record_str}").content

@tool
def summarize_policy_guideline(policy_id: str) -> str:
    policy = policy_dict.get(policy_id)
    if not policy:
        return "Policy not found"
    return llm.invoke(f"Summarize policy {policy_id}:\n{json.dumps(policy)}").content

@tool
def check_claim_coverage(record_summary: str, policy_summary: str) -> str:
    return llm.invoke(
        f"Check coverage:\nRecord:\n{record_summary}\nPolicy:\n{policy_summary}"
    ).content

tools = [summarize_patient_record, summarize_policy_guideline, check_claim_coverage]

system_prompt = """You are a Healthcare Insurance Claim Approval Agent.
Always use the tools in this order:
1. summarize_patient_record
2. summarize_policy_guideline
3. check_claim_coverage
Final output must be:
Decision: APPROVE
Reason: <short reason>
OR
Decision: ROUTE FOR REVIEW
Reason: <short reason>
"""

# --- Build agent manually ---
workflow = StateGraph(MessagesState)

# Tool node
tool_node = ToolNode(tools)

# LLM node
def call_llm(state: MessagesState):
    response = llm.invoke(state["messages"])
    return {"messages": state["messages"] + [response]}

workflow.add_node("agent", call_llm)
workflow.add_node("tools", tool_node)

# Edges: agent → tools → agent
workflow.add_edge("agent", "tools")
workflow.add_conditional_edges("tools", tools_condition)

workflow.set_entry_point("agent")
agent_executor = workflow.compile()

# --- Claim runner ---
def run_claim(rec: dict) -> str:
    messages = [
        SystemMessage(content=system_prompt),
        HumanMessage(content="Evaluate this insurance claim:\n" + json.dumps(rec, indent=2))
    ]
    result = agent_executor.invoke({"messages": messages})
    if "output" in result and result["output"]:
        return result["output"].strip()
    if "messages" in result and result["messages"]:
        return result["messages"][-1].content.strip()
    return "No decision produced by agent."

# --- Batch run ---
results = []
for rec in test_records:
    resp = run_claim(rec)
    results.append({"patient_id": rec["patient_id"], "generated_response": resp})

submission_df = pd.DataFrame(results)[["patient_id", "generated_response"]]
submission_df.to_csv("submission.csv", index=False)
submission_df.head()
